<h1 id="simple-queue-service-analog-in-mysql">Simple Queue Service Analog in MySQL</h1>
<p>Difficulty level: <strong>medium</strong></p>
<p>SQS is a service which allows developers to create queues, put messages in them, and depends on several conditions retrieve them.</p>
<p>One of the use case is to send different tasks between various worker instances</p>
<h2 id="objectives">Objectives</h2>
<p>Create a service where we can create described earlier types of messages.</p>
<p>Be able to retrieve messages, see if there’s any tables locks and not able to retrieve messages more that twice within given period of time.</p>
<p>Use MySQL compatible database (Maria DB, AWS Aurora, MemSQL, etc) for simplicity of implementation, wide support, etc.</p>
<p>For messages we need to be able to make these 3 operations:</p>
<ul>
<li>put message in queue</li>
<li>retrieve latest message</li>
<li>delete/soft delete message from queue</li>
</ul>
<p>In this exercise we’ll learn how to create tables and stored procedures.</p>
<p>Interested…?</p>
<p>-more-</p>
<h2 id="input-details">Input details</h2>
<p>Database/language: <strong>MySQL</strong>/<strong>SQL</strong></p>
<h2 id="implementation">Implementation</h2>
<p>Let’s assume we use a database name <code>main_schema</code>. We need to create a primary table, then related stored procedures.</p>
<h3 id="tables-creation">Tables creation</h3>
<pre><code>DROP TABLE main_schema.main_queue;
CREATE TABLE main_schema.main_queue (
    id BIGINT NOT NULL AUTO_INCREMENT,
    queue_name VARCHAR(64) DEFAULT &#39;default&#39;,
    payload MEDIUMTEXT,
    read_cnt BIGINT DEFAULT 0,
    max_read_cnt BIGINT DEFAULT 1,
    last_read DATETIME(6) DEFAULT &#39;2020-01-01 00:00:00&#39;,
    next_read DATETIME(6) DEFAULT &#39;2020-01-01 00:00:00&#39;,
    invisibility_time BIGINT DEFAULT 0,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY(id)
);</code></pre>
<p><strong>Columns explanation</strong>:</p>
<ul>
<li><code>id</code> - our primary key in the table.</li>
<li><code>queue_name</code> - different queues can handle payload for different tasks.</li>
<li><code>payload</code> - our message to be delivered.</li>
<li><code>read_cnt</code> - this counter indicates how many times message been read already.</li>
<li><code>max_read_cnt</code> - limit how many times the message can be delivered. <code>0</code> means no limit on how many times it can be read.</li>
<li><code>last_read</code> - mark last time message being read.</li>
<li><code>next_read</code> - timestamp when message is visible for reading.</li>
<li><code>invisibility_time</code> - number in seconds how long message is not available for retrieval (helpful if our task needs time to process the message before actual deletion. <code>0</code> means visible immediately.</li>
<li><code>created_at</code> - timestamp when message was created.</li>
</ul>
<p><strong>Indexes</strong> - TBD, but according to the code in the stored procedures, that need to be the following columns <code>next_read</code>, <code>max_read_cnt</code>, <code>read_cnt</code>, <code>queue_name</code>.</p>
<h3 id="stored-procedures---put_message_in_queue">Stored procedures - <code>put_message_in_queue</code></h3>
<pre><code>USE main_schema;
DROP FUNCTION put_message_in_queue;
DELIMITER //
CREATE FUNCTION put_message_in_queue (_queue_name VARCHAR(64), _payload MEDIUMTEXT, _max_read_cnt BIGINT, _invisibility_time BIGINT)
RETURNS BIGINT
DETERMINISTIC
BEGIN
    SET @queue_name = _queue_name;
    SET @payload = _payload;
    SET @max_read_cnt = _max_read_cnt;
    SET @invisibility_time = _invisibility_time;

    INSERT INTO main_schema.main_queue
        (queue_name, payload, max_read_cnt, invisibility_time)
    VALUES
        (@queue_name, @payload, @max_read_cnt, @invisibility_time);

    SET @LID = LAST_INSERT_ID();

    RETURN @LID;
END //
DELIMITER ;
-- SELECT put_message_in_queue (&#39;default&#39;, &#39;{}&#39;, 1, 0);</code></pre>
<h3 id="stored-procedures---get_message_from_queue">Stored procedures - <code>get_message_from_queue</code></h3>
<pre><code>USE main_schema;
DROP PROCEDURE get_message_from_queue;
DELIMITER //
CREATE PROCEDURE get_message_from_queue (IN _queue_name VARCHAR(64))
BEGIN
    START TRANSACTION;
    
    SET @queue_name = _queue_name;
    SET @_now = NOW(6);
    SET @id = (
        SELECT
            id
        FROM
            main_schema.main_queue
        WHERE
            next_read &lt; @_now
            AND (max_read_cnt = 0 || (max_read_cnt != 0 AND max_read_cnt &gt; read_cnt))
            AND queue_name=@queue_name
        ORDER BY id
        LIMIT 1
        FOR UPDATE);
    
    UPDATE
        main_schema.main_queue
    SET
        last_read = @_now,
        read_cnt = read_cnt + 1,
        next_read = DATE_ADD(@_now, INTERVAL invisibility_time SECOND)
    WHERE id=@id;
    
    SELECT * FROM main_schema.main_queue WHERE id = @id FOR UPDATE;
    
    COMMIT;
END //
DELIMITER ;
-- CALL main_schema.get_message_from_queue(&#39;default&#39;)</code></pre>
<h2 id="usage">Usage</h2>
